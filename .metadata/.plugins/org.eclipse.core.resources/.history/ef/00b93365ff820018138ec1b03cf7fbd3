package velvetobj;

import java.util.ArrayList;
import java.util.HashMap;

public class OBJParser
{
	private static final String OBJ_VERTEX 		= "v";
	private static final String OBJ_TEXTURE 	= "vt";
	private static final String OBJ_NORMAL		= "vn";
	private static final String OBJ_FACE		= "f";
	
	private static String 	sFilepath 			= null;
	private static int 		sLinenumber 		= 0;
	
	public static OBJModel parseOBJ(String filepath)
	{
		// Read File //
		String filedata = OBJFileUtils.readFileAsString(filepath);
		
		if(filedata == null)
			System.out.println("[VELVET OBJ] Failed to parse OBJ. File returned null.");
		
		sFilepath 	= null;
		sLinenumber = 0;
		
		// Create Model //
		OBJModel model 	= new OBJModel();
		model.name 		= OBJFileUtils.getFilename(filepath);
		
		// Temporary Lists //
		ArrayList<OBJVertex> 	vertices 	= new ArrayList<>();
		ArrayList<Integer>		indices 	= new ArrayList<>();
		ArrayList<float[]>		positions 	= new ArrayList<>();
		ArrayList<float[]>		textures 	= new ArrayList<>();
		ArrayList<float[]>		normals 	= new ArrayList<>();
		
		HashMap<String, Integer> indexMap	= new HashMap<>();
		
		// Split File //
		String[] lines = filedata.split("\r\n|\r|\n");
		
		// Parse Lines //
		for(String line : lines)
		{
			String[] tokens = tokenize(line, "\\s+");
			
			boolean success = true;
			
			switch(tokens[0])
			{
				case OBJ_VERTEX: 	success = parseVertex(tokens, positions); 			break;
				case OBJ_TEXTURE: 	success = parseTexture(tokens, textures);			break;
				case OBJ_NORMAL: 	success = parseNormal(tokens, normals);				break;
				case OBJ_FACE:	 	success = parseFace(tokens, indices, indexMap);		break;
				
				default: break;
			}
			
			if(!success) return null;
			
			++sLinenumber;
		}
		
		sFilepath 	= null;
		sLinenumber = 0;
		
		return model;
	}

	private static boolean parseVertex(String[] tokens, ArrayList<float[]> positionsList)
	{
		try
		{
			float[] positions = new float[]
			{
				Float.parseFloat(tokens[1]),
				Float.parseFloat(tokens[2]),
				Float.parseFloat(tokens[3]),
			};
			
			positionsList.add(positions);
			
			return true;
		}

		catch(NumberFormatException e)
		{
			objError("Failed to parse float value.");
			return false;
		}
		
		catch(IndexOutOfBoundsException e)
		{
			objError("Too few vertex arguments.");
			return false;
		}
	}
	
	private static boolean parseTexture(String[] tokens, ArrayList<float[]> texturesList)
	{
		try
		{
			float[] textures = new float[]
			{
				Float.parseFloat(tokens[1]),
				Float.parseFloat(tokens[2]),
			};
			
			texturesList.add(textures);
			
			return true;
		}

		catch(NumberFormatException e)
		{
			objError("Failed to parse float value.");
			return false;
		}
		
		catch(IndexOutOfBoundsException e)
		{
			objError("Too few vertex texture arguments.");
			return false;
		}
	}
	
	private static boolean parseNormal(String[] tokens, ArrayList<float[]> normalsList)
	{
		try
		{
			float[] normals = new float[]
			{
				Float.parseFloat(tokens[1]),
				Float.parseFloat(tokens[2]),
				Float.parseFloat(tokens[3]),
			};
			
			normalsList.add(normals);
			
			return true;
		}

		catch(NumberFormatException e)
		{
			objError("Failed to parse float value.");
			return false;
		}
		
		catch(IndexOutOfBoundsException e)
		{
			objError("Too few vertex normal arguments.");
			return false;
		}
	}
	
	private static boolean parseFace(String[] tokens, ArrayList<Integer> indicesList, HashMap<String, Integer> indexMap)
	{
		try
		{
			if(tokens.length > 4)
			{
				//TODO: Triangulate
			}
			
			else
			{
				for(int i = 1; i < tokens.length; i++)
				{
					String[] elements = tokenize(tokens[i], "/");
					
					switch (elements.length)
					{
						case 1:
						{
							
						}
						
						case 2:
						{
							
						}
						
						case 3:
						{
							
						}

						default: objError("Invalid element size."); break;
					}
					
				}
			}
			
			return true;
		}

		catch(NumberFormatException e)
		{
			objError("Failed to parse int value.");
			return false;
		}
		
		catch(IndexOutOfBoundsException e)
		{
			objError("Too few vertex normal arguments.");
			return false;
		}
	}
	
	private static void objError(String error)
	{
		System.out.println("[VELVET OBJ] Error parsing OBJ file:\n\tFILE: " 
				+ sFilepath + "\n\tLINE: " + sLinenumber + "\nREASON: " + error);
	}

	private static String indexHash(OBJIndexGroup index)
	{
		return "" + index.positionIndex + index.texCoordIndex + index.normalIndex;
	}
	
	private static String[] tokenize(String line, String regex)
	{
		return line.trim().toLowerCase().split(regex);
	}
}