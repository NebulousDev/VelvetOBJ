package velvetobj;

import java.util.ArrayList;
import java.util.HashMap;

public class OBJParser
{
	private static final String OBJ_VERTEX 		= "v";
	private static final String OBJ_TEXTURE 	= "vt";
	private static final String OBJ_NORMAL		= "vn";
	private static final String OBJ_FACE		= "f";
	
	private static final int 	NO_INDEX		= -1;
	
	private static String 		sFilepath 		= null;
	private static int 			sLinenumber 	= 0;
	
	public static OBJModel parseOBJ(String filepath)
	{
		// Read File //
		String filedata = OBJFileUtils.readFileAsString(filepath);
		
		if(filedata == null)
			System.out.println("[VELVET OBJ] Failed to parse OBJ. File returned null.");
		
		sFilepath 	= null;
		sLinenumber = 0;
		
		// Create Model //
		OBJModel model 	= new OBJModel();
		model.name 		= OBJFileUtils.getFilename(filepath);
		
		// Temporary Lists //
		ArrayList<OBJVertex> 	vertices 	= new ArrayList<>();
		ArrayList<Integer>		indices 	= new ArrayList<>();
		ArrayList<float[]>		positions 	= new ArrayList<>();
		ArrayList<float[]>		textures 	= new ArrayList<>();
		ArrayList<float[]>		normals 	= new ArrayList<>();
		
		HashMap<String, Integer> indexMap	= new HashMap<>();
		
		// Split File //
		String[] lines = filedata.split("\r\n|\r|\n");
		
		// Parse Lines //
		for(String line : lines)
		{
			String[] tokens = tokenize(line, "\\s+");
			
			boolean success = true;
			
			switch(tokens[0])
			{
				case OBJ_VERTEX: 	success = parseVertex(tokens, positions); 						break;
				case OBJ_TEXTURE: 	success = parseTexture(tokens, textures);						break;
				case OBJ_NORMAL: 	success = parseNormal(tokens, normals);							break;
				case OBJ_FACE:	 	success = parseFace(tokens, positions, textures, normals,
															vertices, indices, indexMap);			break;
				
				default: break;
			}
			
			if(!success) return null;
			
			++sLinenumber;
		}
		
		sFilepath 	= null;
		sLinenumber = 0;
		
		return model;
	}

	private static boolean parseVertex(String[] tokens, ArrayList<float[]> positionsList)
	{
		try
		{
			float[] positions = new float[]
			{
				Float.parseFloat(tokens[1]),
				Float.parseFloat(tokens[2]),
				Float.parseFloat(tokens[3]),
			};
			
			positionsList.add(positions);
			
			return true;
		}

		catch(NumberFormatException e)
		{
			objError("Failed to parse float value.");
			return false;
		}
		
		catch(IndexOutOfBoundsException e)
		{
			objError("Too few vertex arguments.");
			return false;
		}
	}
	
	private static boolean parseTexture(String[] tokens, ArrayList<float[]> texturesList)
	{
		try
		{
			float[] textures = new float[]
			{
				Float.parseFloat(tokens[1]),
				Float.parseFloat(tokens[2]),
			};
			
			texturesList.add(textures);
			
			return true;
		}

		catch(NumberFormatException e)
		{
			objError("Failed to parse float value.");
			return false;
		}
		
		catch(IndexOutOfBoundsException e)
		{
			objError("Too few vertex texture arguments.");
			return false;
		}
	}
	
	private static boolean parseNormal(String[] tokens, ArrayList<float[]> normalsList)
	{
		try
		{
			float[] normals = new float[]
			{
				Float.parseFloat(tokens[1]),
				Float.parseFloat(tokens[2]),
				Float.parseFloat(tokens[3]),
			};
			
			normalsList.add(normals);
			
			return true;
		}

		catch(NumberFormatException e)
		{
			objError("Failed to parse float value.");
			return false;
		}
		
		catch(IndexOutOfBoundsException e)
		{
			objError("Too few vertex normal arguments.");
			return false;
		}
	}
	
	private static boolean parseFace(String[] tokens, ArrayList<float[]> positionsList, ArrayList<float[]> texturesList, ArrayList<float[]> normalsList, 
			ArrayList<OBJVertex> verticesList, ArrayList<Integer> indicesList, HashMap<String, Integer> indexMap)
	{
		try
		{
			if(tokens.length > 4)
			{
				//TODO: Triangulate
			}
			
			else
			{
				for(int i = 1; i < tokens.length; i++)
				{
					String[] elements = tokenize(tokens[i], "/");
					
					int positionIdx 	= NO_INDEX;
					int textureIdx 		= NO_INDEX;
					int normalIdx 		= NO_INDEX;
					
					switch (elements.length)
					{
						case 1:
						{
							positionIdx = Integer.parseInt(elements[0]) - 1;
							break;
						}
						
						case 2:
						{
							positionIdx = Integer.parseInt(elements[0]) - 1;
							textureIdx 	= Integer.parseInt(elements[1]) - 1;
							break;
						}
						
						case 3:
						{
							if(elements[1].equals(""))
							{
								positionIdx = Integer.parseInt(elements[0]) - 1;
								normalIdx 	= Integer.parseInt(elements[2]) - 1;
							}
							
							else
							{
								positionIdx = Integer.parseInt(elements[0]) - 1;
								textureIdx 	= Integer.parseInt(elements[1]) - 1;
								normalIdx 	= Integer.parseInt(elements[2]) - 1;
							}
							
							break;
						}

						default: objError("Invalid element size."); break;
					}
					
					String hash = indexHash(positionIdx, textureIdx, normalIdx);
					
					if(indexMap.containsKey(hash))
						indicesList.add(indexMap.get(hash));
					
					else
					{
						OBJVertex vertex = new OBJVertex();
						
						if(positionIdx != NO_INDEX) vertex.position = positionsList.get(positionIdx);
						
						int index = indexMap.size();
						indicesList.add(index);
						indexMap.put(hash, index);
					}
				}
			}
			
			return true;
		}

		catch(NumberFormatException e)
		{
			objError("Failed to parse int value.");
			return false;
		}
		
		catch(IndexOutOfBoundsException e)
		{
			objError("Too few vertex normal arguments.");
			return false;
		}
	}
	
	private static void objError(String error)
	{
		System.out.println("[VELVET OBJ] Error parsing OBJ file:\n\tFILE: " 
				+ sFilepath + "\n\tLINE: " + sLinenumber + "\nREASON: " + error);
	}

	private static String indexHash(int pos, int tex, int norm)
	{
		return "" + pos + tex + norm;
	}
	
	private static String[] tokenize(String line, String regex)
	{
		return line.trim().toLowerCase().split(regex);
	}
}